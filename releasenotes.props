<Project>
  <PropertyGroup>
    <PackageReleaseNotes Condition="$(VersionPrefix.StartsWith('1.0.0-beta'))">
      <![CDATA[
## DecoWeaver 1.0.0-beta.* - Initial Beta Release

This is the initial beta release of DecoWeaver, a .NET incremental source generator that enables compile-time decorator registration using C# 11+ interceptors.

### Features

* **Compile-time decorator registration** - Zero runtime reflection or assembly scanning
* **Attribute-based decoration** - Support for both `[DecoratedBy<T>]` and `[DecoratedBy(typeof(...))]` attributes
* **Closed generic support** - Works with specific instantiations like `IRepository<Customer>`
* **Open generic decorators** - Decorator classes can be open generics (e.g., `CachingRepository<>`) that are closed at runtime
* **Multiple decorators with ordering** - Stack multiple decorators with explicit order control via `Order` property
* **Keyed services integration** - Uses .NET 8+ keyed services to prevent circular dependencies
* **Incremental source generation** - Fast rebuilds with Roslyn's incremental generator infrastructure
* **Type-safe interceptors** - Generated code uses C# 11+ interceptors to rewrite DI registrations at compile time

### Requirements

* **C# Language Version**: 11 or later (interceptors feature)
* **.NET Runtime**: 8.0 or later (keyed services support)
* **.NET SDK**: 8.0.400 or later (Visual Studio 2022 17.11+)

### Documentation

* Full documentation: https://layeredcraft.github.io/decoweaver/
* Changelog: https://layeredcraft.github.io/decoweaver/changelog/
* GitHub: https://github.com/layeredcraft/decoweaver
* Report issues: https://github.com/layeredcraft/decoweaver/issues

]]>
    </PackageReleaseNotes>

    <PackageReleaseNotes Condition="$(VersionPrefix.StartsWith('1.0.1-beta'))">
      <![CDATA[
## DecoWeaver 1.0.1-beta - Assembly-Level Decorator Support

This release adds assembly-level decorator support, enabling you to apply decorators to all implementations from one central location (Phase 2a of #2).

### New Features

* **Assembly-level `[DecorateService(...)]` attribute** - Apply decorators to all implementations of a service interface from one place
* **`[SkipAssemblyDecoration]` attribute** - Opt out of all assembly-level decorators for a specific implementation
* **`[DoNotDecorate(typeof(TDecorator))]` attribute** - Surgically exclude specific decorators from individual implementations
* **Merge/precedence logic** - Combines class-level and assembly-level decorators with proper ordering
* **Assembly-level decorator ordering** - Control order via `Order` property
* **Open generic matching** - Assembly-level decorators and DoNotDecorate work with open generic patterns
* **4 new test cases** (029-032) covering assembly-level decorator scenarios

### What's Changed

* Decorator discovery pipeline now includes assembly-level attribute streams
* BuildDecorationMap merges and deduplicates decorators from multiple sources
* Documentation restructured to include assembly-level decorator guides

### Technical Details

* Added `DecorateServiceAttribute` for assembly-level decoration
* Added `SkipAssemblyDecorationAttribute` for opting out of all assembly decorators
* Added `DoNotDecorateAttribute` for surgical decorator exclusion
* Added `ServiceDecoratedByProvider` for assembly attribute discovery
* Added `SkipAssemblyDecoratorProvider` for skip directive discovery
* Added `DoNotDecorateProvider` for opt-out directive discovery
* Filtering logic added to BuildDecorationMap for both skip and do-not-decorate support
* Comprehensive test coverage with snapshot verification

### Documentation

* Full documentation: https://layeredcraft.github.io/decoweaver/
* Changelog: https://layeredcraft.github.io/decoweaver/changelog/
* GitHub: https://github.com/layeredcraft/decoweaver

]]>
    </PackageReleaseNotes>

    <PackageReleaseNotes Condition="$(VersionPrefix.StartsWith('1.0.2-beta'))">
      <![CDATA[
## DecoWeaver 1.0.2-beta - Factory Delegate Support

This release adds support for factory delegate registrations, addressing issue #3 (Phase 1).

### New Features

* **Factory delegate support** - Decorators now work with factory delegate registrations:
  - `AddScoped<TService, TImpl>(sp => new TImpl(...))` - Two-parameter generic overload
  - `AddScoped<TService>(sp => new TImpl(...))` - Single-parameter generic overload
  - All lifetimes supported: `AddScoped`, `AddTransient`, `AddSingleton`
* **Complex dependency resolution** - Factory delegates can resolve dependencies from `IServiceProvider`
* **Decorator preservation** - Factory logic is preserved while decorators are applied around the result

### What's Changed

* Extended `ClosedGenericRegistrationProvider` to detect and intercept factory delegate signatures
* Updated `InterceptorEmitter` to generate correct code for factory overloads
* Factory delegates are registered as keyed services, then wrapped with decorators
* All existing functionality remains unchanged - this is purely additive

### Documentation

* Updated sample project with factory delegate examples
* Added comprehensive test coverage (6 new test cases)
* Full documentation: https://layeredcraft.github.io/decoweaver/
* GitHub: https://github.com/layeredcraft/decoweaver

]]>
    </PackageReleaseNotes>

    <PackageReleaseNotes Condition="$(VersionPrefix.StartsWith('1.0.3-beta'))">
      <![CDATA[
## DecoWeaver 1.0.3-beta - Keyed Service Support

This release adds support for keyed service registrations, completing issue #3 (Phase 2).

### New Features

* **Keyed service support** - Decorators now work with keyed service registrations:
  - `AddKeyedScoped<TService, TImpl>(serviceKey)` - Keyed parameterless registration
  - `AddKeyedScoped<TService, TImpl>(serviceKey, factory)` - Keyed with factory delegate (two-parameter)
  - `AddKeyedScoped<TService>(serviceKey, factory)` - Keyed with factory delegate (single-parameter)
  - All lifetimes supported: `AddKeyedScoped`, `AddKeyedTransient`, `AddKeyedSingleton`
* **Multiple keys per service** - Register the same service type with different keys independently
* **All key types supported** - Works with `string`, `int`, `enum`, and custom object keys
* **Nested key strategy** - Prevents circular resolution while preserving user's original key

### What's Changed

* Extended `RegistrationKind` enum with three keyed service variants
* Added `ServiceKeyParameterName` field to `ClosedGenericRegistration` model
* Updated `ClosedGenericRegistrationProvider` to detect keyed service signatures (2 or 3 parameters)
* Updated `InterceptorEmitter` to generate keyed service interceptors with nested key strategy
* Added `ForKeyed` helper method to `DecoratorKeys` class for nested key generation

### Technical Details

* Nested key format: `"{userKey}|{ServiceAQN}|{ImplAQN}"` prevents conflicts between keys
* User's original key preserved for resolution via `GetRequiredKeyedService`
* Each key gets independent decorator chain - no sharing between keys
* 7 new test cases (039-045) covering keyed service scenarios
* Updated sample project with keyed service examples (string and integer keys, multiple keys)
* All existing functionality remains unchanged - this is purely additive

### Documentation

* Full documentation: https://layeredcraft.github.io/decoweaver/
* Changelog: https://layeredcraft.github.io/decoweaver/changelog/
* GitHub: https://github.com/layeredcraft/decoweaver

]]>
    </PackageReleaseNotes>

    <PackageReleaseNotes Condition="$(VersionPrefix.StartsWith('1.0.4-beta'))">
      <![CDATA[
## DecoWeaver 1.0.4-beta - Instance Registration Support

This release adds support for singleton instance registrations, completing issue #3 (Phase 3).

### New Features

* **Instance registration support** - Decorators now work with singleton instance registrations:
  - `AddSingleton<TService>(instance)` - Single type parameter with instance
  - Decorators are applied around the provided instance
  - Only `AddSingleton` is supported (instance registrations don't exist for Scoped/Transient in .NET DI)

### What's Changed

* Extended `RegistrationKind` enum with `InstanceSingleTypeParam` variant
* Added `InstanceParameterName` field to `ClosedGenericRegistration` model
* Updated `ClosedGenericRegistrationProvider` to detect instance registrations (non-delegate second parameter)
* Updated `InterceptorEmitter` to generate instance interceptors with factory lambda wrapping
* Instance type is extracted from the actual argument expression (e.g., `new SqlRepository<Customer>()`)
* Instances are registered as keyed services via factory lambda (keyed services don't have instance overloads)

### Technical Details

* Instance detection: parameter type must match type parameter and NOT be a `Func<>` delegate
* Only `AddSingleton` accepted - `AddScoped`/`AddTransient` don't support instance parameters in .NET DI
* Instance wrapped in factory lambda: `services.AddKeyedSingleton<T>(key, (sp, _) => capturedInstance)`
* Type extraction uses `SemanticModel.GetTypeInfo(instanceArg).Type` to get actual implementation type
* 3 new test cases (047-049) covering instance registration scenarios
* Updated sample project with instance registration example
* All existing functionality remains unchanged - this is purely additive

### Documentation

* Full documentation: https://layeredcraft.github.io/decoweaver/
* Changelog: https://layeredcraft.github.io/decoweaver/changelog/
* GitHub: https://github.com/layeredcraft/decoweaver

]]>
    </PackageReleaseNotes>

    <PackageReleaseNotes Condition="$(VersionPrefix.StartsWith('1.0.5-beta'))">
      <![CDATA[
## DecoWeaver 1.0.5-beta - Scriban Template Migration

This release migrates code generation from StringBuilder to Scriban templates for improved maintainability and readability.

### What's Changed

* **Template-based code generation** - Migrated from StringBuilder to Scriban 6.5.0 template engine
  - Unified template generates all interceptor code (8 registration kinds)
  - Conditional logic handles variations (keyed, factory, instance, two-type-params)
  - Template caching with `ConcurrentDictionary<string, Template>` for performance
  - Strongly-typed `RegistrationModel` (readonly record struct) for zero-boxing overhead
* **Code cleanup** - Removed 570+ lines of StringBuilder emission code
  - Simplified `InterceptorEmitter.cs` from 440+ lines to ~70 lines
  - Removed individual template files (Common/InterceptsLocationAttribute, DecoratorKeys, DecoratorFactory)
  - Single unified template: `DecoWeaverInterceptors.scriban`
* **Comment reduction** - Removed generic "Register X" comments, kept only valuable WHY comments:
  - "Create nested key to avoid circular resolution" - explains nested key purpose
  - "Compose decorators (innermost to outermost)" - explains decorator ordering

### Technical Details

* Added dependency: `Scriban 6.5.0` and `Microsoft.CSharp 4.7.0` (for Scriban's dynamic features)
* Template resource format: `Templates.{FileName}.scriban` embedded in assembly
* No functional changes - generated code is equivalent (except comment reduction)
* All 49 tests passing with updated snapshots
* Build performance unchanged - template compilation is one-time cost with caching

### Documentation

* Full documentation: https://layeredcraft.github.io/decoweaver/
* Changelog: https://layeredcraft.github.io/decoweaver/changelog/
* GitHub: https://github.com/layeredcraft/decoweaver

]]>
    </PackageReleaseNotes>

    <!-- Fallback for versions without specific release notes -->
    <PackageReleaseNotes Condition="'$(PackageReleaseNotes)' == ''">
      <![CDATA[
See the full changelog at https://layeredcraft.github.io/decoweaver/changelog/

Report issues: https://github.com/layeredcraft/decoweaver/issues
]]>
    </PackageReleaseNotes>
  </PropertyGroup>
</Project>