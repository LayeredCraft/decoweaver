// Sculptor/Emit/InterceptorEmitter.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Sculptor.Model;
using Sculptor.Providers;
using Sculptor.Util;

namespace Sculptor.Emit;

/// <summary>Emits the interceptor source for Sculptor's open-generic decoration rewrite.</summary>
internal static class InterceptorEmitter
{
    public static string EmitOpenGenericInterceptors(
        EquatableArray<OpenGenericRegistration> registrations,
        Dictionary<TypeDefId, EquatableArray<TypeDefId>> decoratorsByImplementation)
    {
        var sb = new StringBuilder(16_384);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        EmitInterceptsLocationAttribute(sb);

        sb.AppendLine("namespace Sculptor.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    using System;");
        sb.AppendLine("    using System.Collections.Generic;");
        sb.AppendLine("    using System.Diagnostics;");
        sb.AppendLine("    using System.Runtime.CompilerServices;");
        sb.AppendLine("    using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("    file static class SculptorInterceptors");
        sb.AppendLine("    {");

        // Group registrations by lifetime
        var byLifetime = registrations
            .GroupBy(r => r.Lifetime)
            .ToDictionary(g => g.Key, g => g.ToList());

        // Emit only the methods that are actually used
        if (byLifetime.ContainsKey("AddTransient"))
            EmitAddOverloadWithAttributes(sb, "AddTransient", byLifetime["AddTransient"], decoratorsByImplementation);

        if (byLifetime.ContainsKey("AddScoped"))
            EmitAddOverloadWithAttributes(sb, "AddScoped", byLifetime["AddScoped"], decoratorsByImplementation);

        if (byLifetime.ContainsKey("AddSingleton"))
            EmitAddOverloadWithAttributes(sb, "AddSingleton", byLifetime["AddSingleton"], decoratorsByImplementation);

        EmitHelpers(sb);

        sb.AppendLine("    }"); // class
        sb.AppendLine("}"); // namespace
        return sb.ToString();
    }

    private static void EmitInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
        sb.AppendLine("    {");
        sb.AppendLine("        public InterceptsLocationAttribute(int version, string data) { }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitAddOverloadWithAttributes(
        StringBuilder sb,
        string methodName,
        List<OpenGenericRegistration> registrations,
        Dictionary<TypeDefId, EquatableArray<TypeDefId>> byImpl)
    {
        // Emit all [InterceptsLocation] attributes for this lifetime
        foreach (var reg in registrations)
            sb.AppendLine($"        [InterceptsLocation(version: 1, data: \"{Escape(reg.InterceptsData)}\")]");

        // Emit the method
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}(IServiceCollection, Type, Type)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}(IServiceCollection services, Type serviceType, Type implementationType)");
        sb.AppendLine("        {");
        sb.AppendLine("            // Rewrite only for known open-generic registrations we discovered at compile time.");
        sb.AppendLine("            // Fallback to original method if we don't have a plan for this (service, impl) pair.");
        sb.AppendLine();

        foreach (var reg in registrations)
        {
            var implFqn = ToFqn(reg.ImplDef);

            byImpl.TryGetValue(reg.ImplDef, out var decos);
            var decorators = decos.Count == 0 ? Array.Empty<string>() : decos.Select(ToFqn).ToArray();

            sb.AppendLine($"            if (implementationType == typeof({implFqn}))");
            sb.AppendLine("            {");
            sb.AppendLine("                var key = DecoratorKeys.For(serviceType, implementationType);");
            sb.AppendLine($"                services.{AddKeyed(methodName)}(serviceType, key, implementationType);");
            sb.AppendLine($"                services.{methodName}(serviceType, sp =>");
            sb.AppendLine("                {");
            sb.AppendLine("                    var current = sp.GetRequiredKeyedService(serviceType, key)!;");
            if (decorators.Length > 0)
            {
                sb.AppendLine("                    // Compose decorators (outermost last)");
                foreach (var deco in decorators)
                    sb.AppendLine($"                    current = DecoratorFactory.Create(sp, serviceType, typeof({deco}), current);");
            }
            sb.AppendLine("                    return current!;");
            sb.AppendLine("                });");
            sb.AppendLine("                return services;");
            sb.AppendLine("            }");
            sb.AppendLine();
        }

        sb.AppendLine("            // Fallback to original method for unknown pairs");
        sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}(services, serviceType, implementationType);");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string AddKeyed(string lifetimeMethod) =>
        lifetimeMethod switch
        {
            "AddTransient" => "AddKeyedTransient",
            "AddScoped"    => "AddKeyedScoped",
            _              => "AddKeyedSingleton"
        };

    private static void EmitHelpers(StringBuilder sb)
    {
        sb.AppendLine("        private static class DecoratorKeys");
        sb.AppendLine("        {");
        sb.AppendLine("            public static object For(Type serviceType, Type implementationType)");
        sb.AppendLine("            {");
        sb.AppendLine("                var s = serviceType.AssemblyQualifiedName;");
        sb.AppendLine("                var i = implementationType.AssemblyQualifiedName;");
        sb.AppendLine("                return string.Concat(s, \"|\", i);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        private static class DecoratorFactory");
        sb.AppendLine("        {");
        sb.AppendLine("            public static object Create(IServiceProvider sp, Type serviceType, Type decoratorOpenOrClosed, object inner)");
        sb.AppendLine("            {");
        sb.AppendLine("                var closedType = CloseIfNeeded(decoratorOpenOrClosed, serviceType);");
        sb.AppendLine("                return ActivatorUtilities.CreateInstance(sp, closedType, inner)!;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            private static Type CloseIfNeeded(Type t, Type serviceType)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (!t.IsGenericTypeDefinition) return t;");
        sb.AppendLine("                var args = serviceType.IsGenericType ? serviceType.GetGenericArguments() : Type.EmptyTypes;");
        sb.AppendLine("                return t.MakeGenericType(args);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string ToFqn(TypeDefId t)
    {
        var ns = t.ContainingNamespaces is { Length: > 0 } ? string.Join(".", t.ContainingNamespaces) : null;
        var nest = t.ContainingTypes is { Length: > 0 } ? string.Join("+", t.ContainingTypes) : null;
        var head = ns is null ? "" : ns + ".";
        if (!string.IsNullOrEmpty(nest)) head += nest + ".";

        // Strip backtick notation (e.g., "DynamoDbRepository`1" -> "DynamoDbRepository")
        var metadataName = t.MetadataName;
        var backtickIndex = metadataName.IndexOf('`');
        if (backtickIndex >= 0)
            metadataName = metadataName.Substring(0, backtickIndex);

        // Add <> for open generic types with commas for multiple type parameters
        // Examples: Repository<>, Dictionary<,>, SomeType<,,>
        if (t.Arity > 0)
        {
            var commas = new string(',', t.Arity - 1);
            metadataName = $"{metadataName}<{commas}>";
        }

        // Prepend global:: to avoid namespace conflicts in generated code
        return $"global::{head}{metadataName}";
    }

    private static string Escape(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"");
}
