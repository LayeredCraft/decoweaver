// <auto-generated />
#nullable enable

namespace System.Runtime.CompilerServices
{
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data) { }
    }
}

namespace DecoWeaver.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using Microsoft.Extensions.DependencyInjection;

    file static class DecoWeaverInterceptors
    {
{{- for reg in registrations }}
        [InterceptsLocation(version: 1, data: {{ reg.intercepts_data }})]
        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{{ reg.method_name }}&lt;{{ reg.service_fqn }}{{- if reg.has_two_type_params }}, {{ reg.impl_fqn }}{{- end }}&gt;(IServiceCollection{{- if reg.is_keyed }}, object?{{- end }}{{- if reg.has_factory }}, Func&lt;IServiceProvider{{- if reg.is_keyed }}, object?{{- end }}, {{- if reg.has_two_type_params }} {{ reg.impl_fqn }}{{- else }} {{ reg.service_fqn }}{{- end }}&gt;{{- end }}{{- if reg.has_instance }}, {{ reg.service_fqn }}{{- end }})</summary>
        internal static IServiceCollection {{ reg.method_name }}_{{ reg.method_index }}<TService{{- if reg.has_two_type_params }}, TImplementation{{- end }}>(this IServiceCollection services{{- if reg.is_keyed }}, object? {{ reg.service_key_param }}{{- end }}{{- if reg.has_factory }}, Func<IServiceProvider{{- if reg.is_keyed }}, object?{{- end }}, {{- if reg.has_two_type_params }} TImplementation{{- else }}TService{{- end }}> {{ reg.factory_param }}{{- end }}{{- if reg.has_instance }}, TService {{ reg.instance_param }}{{- end }})
            where TService : class
{{- if reg.has_two_type_params }}
            where TImplementation : class, TService
{{- end }}
        {
{{- if reg.has_decorators }}
{{- if reg.is_keyed }}
            // Create nested key to avoid circular resolution
            var nestedKey = DecoratorKeys.ForKeyed({{ reg.service_key_param }}, typeof({{ reg.service_fqn }}), typeof({{ reg.impl_fqn }}));
{{- if reg.has_instance }}
            var capturedInstance = ({{ reg.service_fqn }})(object){{ reg.instance_param }};
{{ else }}

{{ end -}}
{{- if reg.has_factory }}
            services.{{ reg.method_name }}<{{ reg.service_fqn }}>(nestedKey, (sp, key) => {{- if reg.has_two_type_params }} ({{ reg.service_fqn }}){{- end }}{{ reg.factory_param }}(sp, {{ reg.service_key_param }}));
{{- else if reg.has_instance }}
            services.{{ reg.method_name }}<{{ reg.service_fqn }}>(nestedKey, capturedInstance);
{{- else }}
            services.{{ reg.method_name }}<{{ reg.service_fqn }}, {{ reg.impl_fqn }}>(nestedKey);
{{- end }}

            services.{{ reg.method_name }}<{{ reg.service_fqn }}>({{ reg.service_key_param }}, (sp, key) =>
            {
                var current = ({{ reg.service_fqn }})sp.GetRequiredKeyedService<{{ reg.service_fqn }}>(nestedKey)!;
                // Compose decorators (innermost to outermost)
{{- for decorator in reg.decorators }}
                current = ({{ reg.service_fqn }})DecoratorFactory.Create(sp, typeof({{ reg.service_fqn }}), typeof({{ decorator }}), current);
{{- end }}
                return current;
            });
            return services;
{{- else }}
{{- if reg.has_instance }}
            var key = DecoratorKeys.For(typeof({{ reg.service_fqn }}), typeof({{ reg.impl_fqn }}));
            var capturedInstance = ({{ reg.service_fqn }})(object){{ reg.instance_param }};
            services.{{ reg.keyed_method_name }}<{{ reg.service_fqn }}>(key, capturedInstance);

{{- else if reg.has_factory }}
            var key = DecoratorKeys.For(typeof({{ reg.service_fqn }}), typeof({{ reg.impl_fqn }}));
            services.{{ reg.keyed_method_name }}<{{ reg.service_fqn }}>(key, (sp, _) => {{- if reg.has_two_type_params }} ({{ reg.service_fqn }}){{- end }}{{ reg.factory_param }}(sp));

{{- else }}
            var key = DecoratorKeys.For(typeof({{ reg.service_fqn }}), typeof({{ reg.impl_fqn }}));
            services.{{ reg.keyed_method_name }}<{{ reg.service_fqn }}, {{ reg.impl_fqn }}>(key);

{{- end }}
            services.{{ reg.method_name }}<{{ reg.service_fqn }}>(sp =>
            {
                var current = ({{ reg.service_fqn }})sp.GetRequiredKeyedService<{{ reg.service_fqn }}>(key)!;
                // Compose decorators (innermost to outermost)
{{- for decorator in reg.decorators }}
                current = ({{ reg.service_fqn }})DecoratorFactory.Create(sp, typeof({{ reg.service_fqn }}), typeof({{ decorator }}), current);
{{- end }}
                return current;
            });
            return services;
{{- end }}
{{- else }}
            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{{ reg.method_name }}<{{ reg.service_fqn }}{{- if reg.has_two_type_params }}, {{ reg.impl_fqn }}{{- end }}>(services{{- if reg.is_keyed }}, {{ reg.service_key_param }}{{- end }}{{- if reg.has_factory }}, {{ reg.factory_param }}{{- end }}{{- if reg.has_instance }}, {{ reg.instance_param }}{{- end }});
{{- end }}
        }

{{- end }}

        private static class DecoratorKeys
        {
            public static object For(Type serviceType, Type implementationType)
            {
                var s = serviceType.AssemblyQualifiedName ?? serviceType.FullName ?? serviceType.Name;
                var i = implementationType.AssemblyQualifiedName ?? implementationType.FullName ?? implementationType.Name;
                return string.Concat(s, "|", i);
            }

            public static object ForKeyed(object? userKey, Type serviceType, Type implementationType)
            {
                // Return a tuple that preserves the actual key object (not its string representation)
                // This ensures distinct object keys create distinct nested keys
                return (userKey, serviceType, implementationType);
            }
        }

        private static class DecoratorFactory
        {
            public static object Create(IServiceProvider sp, Type serviceType, Type decoratorOpenOrClosed, object inner)
            {
                var closedType = CloseIfNeeded(decoratorOpenOrClosed, serviceType);
                return ActivatorUtilities.CreateInstance(sp, closedType, inner)!;
            }

            private static Type CloseIfNeeded(Type t, Type serviceType)
            {
                if (!t.IsGenericTypeDefinition) return t;
                var args = serviceType.IsGenericType ? serviceType.GetGenericArguments() : Type.EmptyTypes;
                return t.MakeGenericType(args);
            }
        }

    }
}