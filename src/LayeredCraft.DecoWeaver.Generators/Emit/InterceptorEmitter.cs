// DecoWeaver/Emit/InterceptorEmitter.cs

using System.Text;
using DecoWeaver.Model;
using DecoWeaver.Providers;
using DecoWeaver.Util;
using Microsoft.CodeAnalysis.CSharp;

namespace DecoWeaver.Emit;

/// <summary>Emits the interceptor source for DecoWeaver's open-generic decoration rewrite.</summary>
internal static class InterceptorEmitter
{
    public static string EmitClosedGenericInterceptors(
        EquatableArray<ClosedGenericRegistration> registrations,
        Dictionary<TypeDefId, EquatableArray<TypeDefId>> decoratorsByImplementation)
    {
        var sb = new StringBuilder(16_384);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        EmitInterceptsLocationAttribute(sb);

        sb.AppendLine("namespace DecoWeaver.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    using System;");
        sb.AppendLine("    using System.Collections.Generic;");
        sb.AppendLine("    using System.Diagnostics;");
        sb.AppendLine("    using System.Runtime.CompilerServices;");
        sb.AppendLine("    using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        sb.AppendLine("    file static class DecoWeaverInterceptors");
        sb.AppendLine("    {");

        // Group registrations by lifetime
        var byLifetime = registrations
            .GroupBy(r => r.Lifetime)
            .ToDictionary(g => g.Key, g => g.ToList());

        // Emit one interceptor method per registration
        var methodIndex = 0;
        foreach (var (lifetime, regs) in byLifetime)
        {
            foreach (var reg in regs)
            {
                EmitSingleInterceptor(sb, lifetime, reg, methodIndex++, decoratorsByImplementation);
            }
        }

        EmitHelpers(sb);

        sb.AppendLine("    }"); // class
        sb.AppendLine("}"); // namespace
        return sb.ToString();
    }

    private static void EmitInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
        sb.AppendLine("    {");
        sb.AppendLine("        public InterceptsLocationAttribute(int version, string data) { }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitSingleInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        Dictionary<TypeDefId, EquatableArray<TypeDefId>> byImpl)
    {
        // Use the pre-generated FQNs for closed types from the registration
        var serviceFqn = reg.ServiceFqn;
        var implFqn = reg.ImplFqn;

        var decorators = byImpl.TryGetValue(reg.ImplDef, out var decos) && decos.Count > 0
            ? decos.Select(ToFqn).ToArray()
            : Array.Empty<string>();

        // Emit the [InterceptsLocation] attribute
        sb.AppendLine($"        [InterceptsLocation(version: 1, data: {Escape(reg.InterceptsData)})]");

        // Emit the method - MUST be generic to match the original signature
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}, {implFqn}&gt;(IServiceCollection)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService, TImplementation>(this IServiceCollection services)");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("            where TImplementation : class, TService");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Register the undecorated implementation as a keyed service");
            sb.AppendLine($"            var key = DecoratorKeys.For(typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine($"            services.{AddKeyed(methodName)}<{serviceFqn}, {implFqn}>(key);");
            sb.AppendLine();
            sb.AppendLine("            // Register factory that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(sp =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(key)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, just register normally");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}, {implFqn}>(services);");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string AddKeyed(string lifetimeMethod) =>
        lifetimeMethod switch
        {
            "AddTransient" => "AddKeyedTransient",
            "AddScoped"    => "AddKeyedScoped",
            _              => "AddKeyedSingleton"
        };

    private static void EmitHelpers(StringBuilder sb)
    {
        sb.AppendLine("        private static class DecoratorKeys");
        sb.AppendLine("        {");
        sb.AppendLine("            public static object For(Type serviceType, Type implementationType)");
        sb.AppendLine("            {");
        sb.AppendLine("                var s = serviceType.AssemblyQualifiedName ?? serviceType.FullName ?? serviceType.Name;");
        sb.AppendLine("                var i = implementationType.AssemblyQualifiedName ?? implementationType.FullName ?? implementationType.Name;");
        sb.AppendLine("                return string.Concat(s, \"|\", i);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        private static class DecoratorFactory");
        sb.AppendLine("        {");
        sb.AppendLine("            public static object Create(IServiceProvider sp, Type serviceType, Type decoratorOpenOrClosed, object inner)");
        sb.AppendLine("            {");
        sb.AppendLine("                var closedType = CloseIfNeeded(decoratorOpenOrClosed, serviceType);");
        sb.AppendLine("                return ActivatorUtilities.CreateInstance(sp, closedType, inner)!;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            private static Type CloseIfNeeded(Type t, Type serviceType)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (!t.IsGenericTypeDefinition) return t;");
        sb.AppendLine("                var args = serviceType.IsGenericType ? serviceType.GetGenericArguments() : Type.EmptyTypes;");
        sb.AppendLine("                return t.MakeGenericType(args);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string ToFqn(TypeDefId t)
    {
        var ns = t.ContainingNamespaces is { Count: > 0 } ? string.Join(".", t.ContainingNamespaces) : null;
        var nest = t.ContainingTypes is { Count: > 0 } ? string.Join("+", t.ContainingTypes) : null;
        var head = ns is null ? "" : ns + ".";
        if (!string.IsNullOrEmpty(nest)) head += nest + ".";

        // Strip backtick notation (e.g., "DynamoDbRepository`1" -> "DynamoDbRepository")
        var metadataName = t.MetadataName;
        var backtickIndex = metadataName.IndexOf('`');
        if (backtickIndex >= 0)
            metadataName = metadataName.Substring(0, backtickIndex);

        // Add <> for open generic types with commas for multiple type parameters
        // Examples: Repository<>, Dictionary<,>, SomeType<,,>
        if (t.Arity > 0)
        {
            var commas = new string(',', t.Arity - 1);
            metadataName = $"{metadataName}<{commas}>";
        }

        // Prepend global:: to avoid namespace conflicts in generated code
        return $"global::{head}{metadataName}";
    }

    private static string Escape(string s) =>
        SymbolDisplay.FormatLiteral(s, quote: true);
}
