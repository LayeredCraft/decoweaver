// DecoWeaver/Emit/InterceptorEmitter.cs

using System.Text;
using DecoWeaver.Model;
using DecoWeaver.Providers;
using DecoWeaver.Util;
using Microsoft.CodeAnalysis.CSharp;

namespace DecoWeaver.Emit;

/// <summary>Emits the interceptor source for DecoWeaver's open-generic decoration rewrite.</summary>
internal static class InterceptorEmitter
{
    public static string EmitClosedGenericInterceptors(
        EquatableArray<ClosedGenericRegistration> registrations,
        Dictionary<TypeDefId, EquatableArray<TypeDefId>> decoratorsByImplementation)
    {
        var sb = new StringBuilder(16_384);

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        EmitInterceptsLocationAttribute(sb);

        sb.AppendLine("namespace DecoWeaver.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    using System;");
        sb.AppendLine("    using System.Collections.Generic;");
        sb.AppendLine("    using System.Diagnostics;");
        sb.AppendLine("    using System.Runtime.CompilerServices;");
        sb.AppendLine("    using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();

        sb.AppendLine("    file static class DecoWeaverInterceptors");
        sb.AppendLine("    {");

        // Group registrations by lifetime
        var byLifetime = registrations
            .GroupBy(r => r.Lifetime)
            .ToDictionary(g => g.Key, g => g.ToList());

        // Emit one interceptor method per registration
        var methodIndex = 0;
        foreach (var (lifetime, regs) in byLifetime)
        {
            foreach (var reg in regs)
            {
                EmitSingleInterceptor(sb, lifetime, reg, methodIndex++, decoratorsByImplementation);
            }
        }

        EmitHelpers(sb);

        sb.AppendLine("    }"); // class
        sb.AppendLine("}"); // namespace
        return sb.ToString();
    }

    private static void EmitInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("namespace System.Runtime.CompilerServices");
        sb.AppendLine("{");
        sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
        sb.AppendLine("    {");
        sb.AppendLine("        public InterceptsLocationAttribute(int version, string data) { }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void EmitSingleInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        Dictionary<TypeDefId, EquatableArray<TypeDefId>> byImpl)
    {
        // Use the pre-generated FQNs for closed types from the registration
        var serviceFqn = reg.ServiceFqn;
        var implFqn = reg.ImplFqn;

        var decorators = byImpl.TryGetValue(reg.ImplDef, out var decos) && decos.Count > 0
            ? decos.Select(ToFqn).ToArray()
            : Array.Empty<string>();

        // Emit the [InterceptsLocation] attribute
        sb.AppendLine($"        [InterceptsLocation(version: 1, data: {Escape(reg.InterceptsData)})]");

        // Branch on registration kind to emit the correct signature
        switch (reg.Kind)
        {
            case RegistrationKind.Parameterless:
                EmitParameterlessInterceptor(sb, methodName, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.FactoryTwoTypeParams:
                EmitFactoryTwoTypeParamsInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.FactorySingleTypeParam:
                EmitFactorySingleTypeParamInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.KeyedParameterless:
                EmitKeyedParameterlessInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.KeyedFactoryTwoTypeParams:
                EmitKeyedFactoryTwoTypeParamsInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.KeyedFactorySingleTypeParam:
                EmitKeyedFactorySingleTypeParamInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.InstanceSingleTypeParam:
                EmitInstanceSingleTypeParamInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            case RegistrationKind.KeyedInstanceSingleTypeParam:
                EmitKeyedInstanceSingleTypeParamInterceptor(sb, methodName, reg, methodIndex, serviceFqn, implFqn, decorators);
                break;

            default:
                throw new InvalidOperationException($"Unsupported registration kind: {reg.Kind}");
        }
    }

    private static void EmitParameterlessInterceptor(
        StringBuilder sb,
        string methodName,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        // Emit the method - MUST be generic to match the original signature
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}, {implFqn}&gt;(IServiceCollection)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService, TImplementation>(this IServiceCollection services)");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("            where TImplementation : class, TService");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Register the undecorated implementation as a keyed service");
            sb.AppendLine($"            var key = DecoratorKeys.For(typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine($"            services.{AddKeyed(methodName)}<{serviceFqn}, {implFqn}>(key);");
            sb.AppendLine();
            sb.AppendLine("            // Register factory that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(sp =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(key)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, just register normally");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}, {implFqn}>(services);");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitFactoryTwoTypeParamsInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var factoryParamName = reg.FactoryParameterName ?? "implementationFactory";

        // Emit the method signature matching AddScoped<T1, T2>(services, Func<IServiceProvider, T2>)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}, {implFqn}&gt;(IServiceCollection, Func&lt;IServiceProvider, {implFqn}&gt;)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService, TImplementation>(this IServiceCollection services, Func<IServiceProvider, TImplementation> {factoryParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("            where TImplementation : class, TService");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Register the undecorated implementation as a keyed service with factory");
            sb.AppendLine($"            var key = DecoratorKeys.For(typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine($"            services.{AddKeyed(methodName)}<{serviceFqn}>(key, (sp, _) => ({serviceFqn}){factoryParamName}(sp));");
            sb.AppendLine();
            sb.AppendLine("            // Register factory that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(sp =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(key)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, pass through to original method with factory");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}, {implFqn}>(services, {factoryParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitFactorySingleTypeParamInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var factoryParamName = reg.FactoryParameterName ?? "implementationFactory";

        // Emit the method signature matching AddScoped<T>(services, Func<IServiceProvider, T>)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}&gt;(IServiceCollection, Func&lt;IServiceProvider, {serviceFqn}&gt;)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService>(this IServiceCollection services, Func<IServiceProvider, TService> {factoryParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Register the undecorated implementation as a keyed service with factory");
            sb.AppendLine($"            var key = DecoratorKeys.For(typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine($"            services.{AddKeyed(methodName)}<{serviceFqn}>(key, (sp, _) => {factoryParamName}(sp));");
            sb.AppendLine();
            sb.AppendLine("            // Register factory that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(sp =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(key)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, pass through to original method with factory");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}>(services, {factoryParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitKeyedParameterlessInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var serviceKeyParamName = reg.ServiceKeyParameterName ?? "serviceKey";

        // Emit the method signature matching AddKeyedScoped<T1, T2>(services, object? serviceKey)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}, {implFqn}&gt;(IServiceCollection, object?)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService, TImplementation>(this IServiceCollection services, object? {serviceKeyParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("            where TImplementation : class, TService");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Create nested key to avoid circular resolution");
            sb.AppendLine($"            var nestedKey = DecoratorKeys.ForKeyed({serviceKeyParamName}, typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine();
            sb.AppendLine("            // Register the undecorated implementation with nested key");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}, {implFqn}>(nestedKey);");
            sb.AppendLine();
            sb.AppendLine("            // Register factory with user's key that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>({serviceKeyParamName}, (sp, key) =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(nestedKey)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, just register normally");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}, {implFqn}>(services, {serviceKeyParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitKeyedFactoryTwoTypeParamsInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var serviceKeyParamName = reg.ServiceKeyParameterName ?? "serviceKey";
        var factoryParamName = reg.FactoryParameterName ?? "implementationFactory";

        // Emit the method signature matching AddKeyedScoped<T1, T2>(services, object? serviceKey, Func<IServiceProvider, object?, T2>)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}, {implFqn}&gt;(IServiceCollection, object?, Func&lt;IServiceProvider, object?, {implFqn}&gt;)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService, TImplementation>(this IServiceCollection services, object? {serviceKeyParamName}, Func<IServiceProvider, object?, TImplementation> {factoryParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("            where TImplementation : class, TService");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Create nested key to avoid circular resolution");
            sb.AppendLine($"            var nestedKey = DecoratorKeys.ForKeyed({serviceKeyParamName}, typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine();
            sb.AppendLine("            // Register the undecorated implementation with nested key and factory");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(nestedKey, (sp, key) => ({serviceFqn}){factoryParamName}(sp, {serviceKeyParamName}));");
            sb.AppendLine();
            sb.AppendLine("            // Register factory with user's key that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>({serviceKeyParamName}, (sp, key) =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(nestedKey)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, pass through to original method with factory");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}, {implFqn}>(services, {serviceKeyParamName}, {factoryParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitKeyedFactorySingleTypeParamInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var serviceKeyParamName = reg.ServiceKeyParameterName ?? "serviceKey";
        var factoryParamName = reg.FactoryParameterName ?? "implementationFactory";

        // Emit the method signature matching AddKeyedScoped<T>(services, object? serviceKey, Func<IServiceProvider, object?, T>)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}&gt;(IServiceCollection, object?, Func&lt;IServiceProvider, object?, {serviceFqn}&gt;)</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService>(this IServiceCollection services, object? {serviceKeyParamName}, Func<IServiceProvider, object?, TService> {factoryParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Create nested key to avoid circular resolution");
            sb.AppendLine($"            var nestedKey = DecoratorKeys.ForKeyed({serviceKeyParamName}, typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine();
            sb.AppendLine("            // Register the undecorated implementation with nested key and factory");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(nestedKey, (sp, key) => {factoryParamName}(sp, {serviceKeyParamName}));");
            sb.AppendLine();
            sb.AppendLine("            // Register factory with user's key that applies decorators");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>({serviceKeyParamName}, (sp, key) =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(nestedKey)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, pass through to original method with factory");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}>(services, {serviceKeyParamName}, {factoryParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitInstanceSingleTypeParamInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var instanceParamName = reg.InstanceParameterName ?? "implementationInstance";

        // Emit the method signature matching AddSingleton<T>(services, T instance)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}&gt;(IServiceCollection, {serviceFqn})</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService>(this IServiceCollection services, TService {instanceParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Register the undecorated instance as a keyed service");
            sb.AppendLine($"            var key = DecoratorKeys.For(typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine($"            var capturedInstance = ({serviceFqn})(object){instanceParamName};");
            sb.AppendLine($"            services.{AddKeyed(methodName)}<{serviceFqn}>(key, capturedInstance);");
            sb.AppendLine();
            sb.AppendLine("            // Register factory that applies decorators around the instance");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(sp =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(key)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, pass through to original method with instance");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}>(services, {instanceParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void EmitKeyedInstanceSingleTypeParamInterceptor(
        StringBuilder sb,
        string methodName,
        ClosedGenericRegistration reg,
        int methodIndex,
        string serviceFqn,
        string implFqn,
        string[] decorators)
    {
        var serviceKeyParamName = reg.ServiceKeyParameterName ?? "serviceKey";
        var instanceParamName = reg.InstanceParameterName ?? "implementationInstance";

        // Emit the method signature matching AddKeyedSingleton<T>(services, object? serviceKey, T instance)
        sb.AppendLine($"        /// <summary>Intercepted: ServiceCollectionServiceExtensions.{methodName}&lt;{serviceFqn}&gt;(IServiceCollection, object?, {serviceFqn})</summary>");
        sb.AppendLine($"        internal static IServiceCollection {methodName}_{methodIndex}<TService>(this IServiceCollection services, object? {serviceKeyParamName}, TService {instanceParamName})");
        sb.AppendLine("            where TService : class");
        sb.AppendLine("        {");

        if (decorators.Length > 0)
        {
            sb.AppendLine("            // Create nested key to avoid circular resolution");
            sb.AppendLine($"            var nestedKey = DecoratorKeys.ForKeyed({serviceKeyParamName}, typeof({serviceFqn}), typeof({implFqn}));");
            sb.AppendLine($"            var capturedInstance = ({serviceFqn})(object){instanceParamName};");
            sb.AppendLine();
            sb.AppendLine("            // Register the undecorated instance with nested key");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>(nestedKey, capturedInstance);");
            sb.AppendLine();
            sb.AppendLine("            // Register factory with user's key that applies decorators around the instance");
            sb.AppendLine($"            services.{methodName}<{serviceFqn}>({serviceKeyParamName}, (sp, key) =>");
            sb.AppendLine("            {");
            sb.AppendLine($"                var current = ({serviceFqn})sp.GetRequiredKeyedService<{serviceFqn}>(nestedKey)!;");
            sb.AppendLine("                // Compose decorators (innermost to outermost)");
            foreach (var deco in decorators)
                sb.AppendLine($"                current = ({serviceFqn})DecoratorFactory.Create(sp, typeof({serviceFqn}), typeof({deco}), current);");
            sb.AppendLine("                return current;");
            sb.AppendLine("            });");
            sb.AppendLine("            return services;");
        }
        else
        {
            sb.AppendLine("            // No decorators, pass through to original method with instance");
            sb.AppendLine($"            return Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.{methodName}<{serviceFqn}>(services, {serviceKeyParamName}, {instanceParamName});");
        }

        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string AddKeyed(string lifetimeMethod) =>
        lifetimeMethod switch
        {
            "AddTransient" => "AddKeyedTransient",
            "AddScoped"    => "AddKeyedScoped",
            _              => "AddKeyedSingleton"
        };

    private static void EmitHelpers(StringBuilder sb)
    {
        sb.AppendLine("        private static class DecoratorKeys");
        sb.AppendLine("        {");
        sb.AppendLine("            public static object For(Type serviceType, Type implementationType)");
        sb.AppendLine("            {");
        sb.AppendLine("                var s = serviceType.AssemblyQualifiedName ?? serviceType.FullName ?? serviceType.Name;");
        sb.AppendLine("                var i = implementationType.AssemblyQualifiedName ?? implementationType.FullName ?? implementationType.Name;");
        sb.AppendLine("                return string.Concat(s, \"|\", i);");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            public static object ForKeyed(object? userKey, Type serviceType, Type implementationType)");
        sb.AppendLine("            {");
        sb.AppendLine("                // Return a tuple that preserves the actual key object (not its string representation)");
        sb.AppendLine("                // This ensures distinct object keys create distinct nested keys");
        sb.AppendLine("                return (userKey, serviceType, implementationType);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();

        sb.AppendLine("        private static class DecoratorFactory");
        sb.AppendLine("        {");
        sb.AppendLine("            public static object Create(IServiceProvider sp, Type serviceType, Type decoratorOpenOrClosed, object inner)");
        sb.AppendLine("            {");
        sb.AppendLine("                var closedType = CloseIfNeeded(decoratorOpenOrClosed, serviceType);");
        sb.AppendLine("                return ActivatorUtilities.CreateInstance(sp, closedType, inner)!;");
        sb.AppendLine("            }");
        sb.AppendLine();
        sb.AppendLine("            private static Type CloseIfNeeded(Type t, Type serviceType)");
        sb.AppendLine("            {");
        sb.AppendLine("                if (!t.IsGenericTypeDefinition) return t;");
        sb.AppendLine("                var args = serviceType.IsGenericType ? serviceType.GetGenericArguments() : Type.EmptyTypes;");
        sb.AppendLine("                return t.MakeGenericType(args);");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static string ToFqn(TypeDefId t)
    {
        var ns = t.ContainingNamespaces is { Count: > 0 } ? string.Join(".", t.ContainingNamespaces) : null;
        var nest = t.ContainingTypes is { Count: > 0 } ? string.Join("+", t.ContainingTypes) : null;
        var head = ns is null ? "" : ns + ".";
        if (!string.IsNullOrEmpty(nest)) head += nest + ".";

        // Strip backtick notation (e.g., "DynamoDbRepository`1" -> "DynamoDbRepository")
        var metadataName = t.MetadataName;
        var backtickIndex = metadataName.IndexOf('`');
        if (backtickIndex >= 0)
            metadataName = metadataName.Substring(0, backtickIndex);

        // Add <> for open generic types with commas for multiple type parameters
        // Examples: Repository<>, Dictionary<,>, SomeType<,,>
        if (t.Arity > 0)
        {
            var commas = new string(',', t.Arity - 1);
            metadataName = $"{metadataName}<{commas}>";
        }

        // Prepend global:: to avoid namespace conflicts in generated code
        return $"global::{head}{metadataName}";
    }

    private static string Escape(string s) =>
        SymbolDisplay.FormatLiteral(s, quote: true);
}
