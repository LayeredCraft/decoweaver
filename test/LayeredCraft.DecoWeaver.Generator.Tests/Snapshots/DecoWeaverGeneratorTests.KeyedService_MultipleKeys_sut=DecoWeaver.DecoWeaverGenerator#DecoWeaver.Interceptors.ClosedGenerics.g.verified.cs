//HintName: DecoWeaver.Interceptors.ClosedGenerics.g.cs
// <auto-generated />
#nullable enable

namespace System.Runtime.CompilerServices
{
    file sealed class InterceptsLocationAttribute : Attribute
    {
        public InterceptsLocationAttribute(int version, string data) { }
    }
}

namespace DecoWeaver.Generated
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Runtime.CompilerServices;
    using Microsoft.Extensions.DependencyInjection;

    file static class DecoWeaverInterceptors
    {
        [InterceptsLocation(version: 1, data: "fAbqH9Sp6B/0qH0FYFTTab4AAABQcm9ncmFtLmNz")]
        /// <summary>Intercepted: ServiceCollectionServiceExtensions.AddKeyedScoped&lt;global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>, global::DecoWeaver.Sample.SqlRepository<global::DecoWeaver.Sample.User>&gt;(IServiceCollection, object?)</summary>
        internal static IServiceCollection AddKeyedScoped_0<TService, TImplementation>(this IServiceCollection services, object? serviceKey)
            where TService : class
            where TImplementation : class, TService
        {
            // Create nested key to avoid circular resolution
            var nestedKey = DecoratorKeys.ForKeyed(serviceKey, typeof(global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>), typeof(global::DecoWeaver.Sample.SqlRepository<global::DecoWeaver.Sample.User>));

            // Register the undecorated implementation with nested key
            services.AddKeyedScoped<global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>, global::DecoWeaver.Sample.SqlRepository<global::DecoWeaver.Sample.User>>(nestedKey);

            // Register factory with user's key that applies decorators
            services.AddKeyedScoped<global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>>(serviceKey, (sp, key) =>
            {
                var current = (global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>)sp.GetRequiredKeyedService<global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>>(nestedKey)!;
                // Compose decorators (innermost to outermost)
                current = (global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>)DecoratorFactory.Create(sp, typeof(global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>), typeof(global::DecoWeaver.Sample.CachingRepository<>), current);
                return current;
            });
            return services;
        }

        [InterceptsLocation(version: 1, data: "fAbqH9Sp6B/0qH0FYFTTaQYBAABQcm9ncmFtLmNz")]
        /// <summary>Intercepted: ServiceCollectionServiceExtensions.AddKeyedScoped&lt;global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>, global::DecoWeaver.Sample.CosmosRepository<global::DecoWeaver.Sample.User>&gt;(IServiceCollection, object?)</summary>
        internal static IServiceCollection AddKeyedScoped_1<TService, TImplementation>(this IServiceCollection services, object? serviceKey)
            where TService : class
            where TImplementation : class, TService
        {
            // Create nested key to avoid circular resolution
            var nestedKey = DecoratorKeys.ForKeyed(serviceKey, typeof(global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>), typeof(global::DecoWeaver.Sample.CosmosRepository<global::DecoWeaver.Sample.User>));

            // Register the undecorated implementation with nested key
            services.AddKeyedScoped<global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>, global::DecoWeaver.Sample.CosmosRepository<global::DecoWeaver.Sample.User>>(nestedKey);

            // Register factory with user's key that applies decorators
            services.AddKeyedScoped<global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>>(serviceKey, (sp, key) =>
            {
                var current = (global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>)sp.GetRequiredKeyedService<global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>>(nestedKey)!;
                // Compose decorators (innermost to outermost)
                current = (global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>)DecoratorFactory.Create(sp, typeof(global::DecoWeaver.Sample.IRepository<global::DecoWeaver.Sample.User>), typeof(global::DecoWeaver.Sample.CachingRepository<>), current);
                return current;
            });
            return services;
        }

        private static class DecoratorKeys
        {
            public static object For(Type serviceType, Type implementationType)
            {
                var s = serviceType.AssemblyQualifiedName ?? serviceType.FullName ?? serviceType.Name;
                var i = implementationType.AssemblyQualifiedName ?? implementationType.FullName ?? implementationType.Name;
                return string.Concat(s, "|", i);
            }

            public static object ForKeyed(object? userKey, Type serviceType, Type implementationType)
            {
                var s = serviceType.AssemblyQualifiedName ?? serviceType.FullName ?? serviceType.Name;
                var i = implementationType.AssemblyQualifiedName ?? implementationType.FullName ?? implementationType.Name;
                var keyStr = userKey?.ToString() ?? "null";
                return string.Concat(keyStr, "|", s, "|", i);
            }
        }

        private static class DecoratorFactory
        {
            public static object Create(IServiceProvider sp, Type serviceType, Type decoratorOpenOrClosed, object inner)
            {
                var closedType = CloseIfNeeded(decoratorOpenOrClosed, serviceType);
                return ActivatorUtilities.CreateInstance(sp, closedType, inner)!;
            }

            private static Type CloseIfNeeded(Type t, Type serviceType)
            {
                if (!t.IsGenericTypeDefinition) return t;
                var args = serviceType.IsGenericType ? serviceType.GetGenericArguments() : Type.EmptyTypes;
                return t.MakeGenericType(args);
            }
        }

    }
}
